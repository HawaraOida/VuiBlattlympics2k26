<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-slate-100 text-slate-800 pb-20">

    <div id="app-content" class="fade-in">
        <p class="text-center text-slate-500 mt-10">Daten werden geladen...</p> 
    </div>
</div>

<script>
    const K_FACTOR = 32;

    // --- 2. SUPABASE KONFIGURATION ---
    const SUPABASE_URL = 'https://tbeupewhdgcyxugxsfjd.supabase.co'; // <-- HIER ERSETZEN!
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZXVwZXdoZGdjeXh1Z3hzZmpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM3NDY4NzIsImV4cCI6MjA3OTMyMjg3Mn0.hqICv1Yy4spdJa6sKZSnDXQL2r0sCHlBg3CL1DE10BU'; // <-- HIER ERSETZEN!

    // Supabase Client initialisieren
    const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    // ---------------------------------
    
    const app = {
        data: {
            players: [],
            history: [],
            activeTab: 'rank',
            matchInputs: Array(8).fill(''),
            winnerMode: 0 // 0 = Ranking, 1 = Winner Takes All
        },

        init() {
            // Daten aus Supabase laden
            this.fetchData()
                .then(() => this.render())
                .catch(() => this.renderError());
        },

        // --- 3. DATEN LADEN (fetchData ersetzt loadData) ---
        fetchData() {
            return new Promise(async (resolve, reject) => {
                try {
                    // 1. Spielerdaten abrufen (sortiert nach Elo absteigend)
                    let { data: players, error: playersError } = await supabase
                        .from('players')
                        .select('id, name, elo, matches, wins')
                        .order('elo', { ascending: false });

                    if (playersError) throw playersError;

                    // 2. History-Daten abrufen
                    let { data: history, error: historyError } = await supabase
                        .from('history')
                        .select('date, mode, ranking')
                        .order('date', { ascending: false });
                    
                    if (historyError) throw historyError;

                    this.data.players = players || [];
                    this.data.history = (history || []).map(entry => ({
                        ...entry,
                        ranking: entry.ranking.split(',').map(s => s.trim())
                    }));

                    // Initiale Daten, falls DB leer ist
                    if (this.data.players.length === 0) {
                         this.data.players = Array.from({length: 8}, (_, i) => ({
                            id: 'p' + (i+1),
                            name: 'Saufi ' + (i+1),
                            elo: 1000,
                            matches: 0,
                            wins: 0
                        }));
                        await this.saveInitialPlayers(this.data.players);
                    }

                    resolve(true);

                } catch (error) {
                    console.error("Fehler beim Laden der Daten von Supabase:", error);
                    alert("Fehler beim Laden der Daten. Bitte prüfen Sie die Konsole.");
                    reject(error);
                }
            });
        },

        async saveInitialPlayers(players) {
             const { error } = await supabase
                .from('players')
                .insert(players);
             if (error) console.error("Fehler beim Speichern der Initialspieler:", error);
        },

        // --- 4. DATEN SPEICHERN (saveData ersetzt lokale Speicherung) ---
        saveData(newHistoryEntry) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 1. Spielerdaten aktualisieren (Löschen und neu einfügen)
                    const { error: deleteError } = await supabase
                        .from('players')
                        .delete()
                        .neq('id', null);
                    if (deleteError) throw deleteError;
                    
                    const { error: insertPlayersError } = await supabase
                        .from('players')
                        .insert(this.data.players.map(p => ({
                            id: p.id,
                            name: p.name,
                            elo: p.elo,
                            matches: p.matches,
                            wins: p.wins
                        })));
                    if (insertPlayersError) throw insertPlayersError;


                    // 2. Neuen History-Eintrag hinzufügen
                    const { error: insertHistoryError } = await supabase
                        .from('history')
                        .insert([
                            {
                                date: newHistoryEntry.date,
                                mode: newHistoryEntry.mode,
                                ranking: newHistoryEntry.ranking.join(', ') // Als String speichern
                            }
                        ]);
                    if (insertHistoryError) throw insertHistoryError;

                    resolve(true);
                    
                } catch (error) {
                    console.error("Fehler beim Speichern der Daten in Supabase:", error);
                    alert("Fehler beim Speichern der Daten. Bitte prüfen Sie die Konsole.");
                    reject(error);
                }
            });
        },
        
        resetData() {
            if(confirm("Wirklich alles löschen? Alle Spielstände gehen verloren und die Datenbank wird zurückgesetzt!")) {
                this.resetSupabaseData()
                    .then(() => location.reload())
                    .catch(err => alert("Fehler beim Zurücksetzen der Datenbank: " + err.message));
            }
        },
        
        async resetSupabaseData() {
             // Löschen aller Spieler
            const { error: deletePlayersError } = await supabase
                .from('players')
                .delete()
                .neq('id', null);
            if (deletePlayersError) throw deletePlayersError;

            // Löschen aller History-Einträge
            const { error: deleteHistoryError } = await supabase
                .from('history')
                .delete()
                .neq('date', null);
            if (deleteHistoryError) throw deleteHistoryError;
        },


        setTab(tab) {
            this.data.activeTab = tab;
            this.render();
        },

        setWinnerMode(mode) {
            this.data.winnerMode = mode;
            this.render();
        },

        updateMatchInput(index, value) {
            this.data.matchInputs[index] = value;
            // Re-render nicht nötig für Input-Werte
        },

        updatePlayerName(id, newName) {
            const p = this.data.players.find(pl => pl.id === id);
            if(p) {
                p.name = newName;
                // Daten nach jeder Namensänderung speichern
                this.saveData({}) 
                    .then(() => this.render())
                    .catch(err => console.error("Speicherfehler nach Namensänderung", err));
            }
        },

        getExpectation(ra, rb) {
            return 1 / (1 + Math.pow(10, (rb - ra) / 400));
        },

        submitMatch() {
            // Inputs auslesen (da wir kein React haben, holen wir die Werte direkt)
            const inputs = [];
            for(let i=0; i<8; i++) {
                const el = document.getElementById(`match-select-${i}`);
                if(el) inputs.push(el.value);
            }

            const activeIds = inputs.filter(id => id !== "");

            if (activeIds.length < 2) return alert("Mindestens 2 Spieler nötig!");
            if (new Set(activeIds).size !== activeIds.length) return alert("Spieler doppelt ausgewählt!");

            // Berechnung
            const eloDeltas = {};
            activeIds.forEach(id => eloDeltas[id] = 0);
            const playersMap = new Map(this.data.players.map(p => [p.id, {...p}]));

            for (let i = 0; i < activeIds.length; i++) {
                const pA = playersMap.get(activeIds[i]);
                for (let j = i + 1; j < activeIds.length; j++) {
                    const pB = playersMap.get(activeIds[j]);
                    
                    if (this.data.winnerMode === 1 && i > 0) continue; // Winner takes all logic

                    const expA = this.getExpectation(pA.elo, pB.elo);
                    const expB = this.getExpectation(pB.elo, pA.elo);

                    // 1: Gewonnen, 0: Verloren
                    const scoreA = (i < j) ? 1 : 0; 
                    const scoreB = (j > i) ? 0 : 1; 

                    // Spezialfall: Wenn nur Winner-Mode aktiv ist, wird nur 1. vs Rest gerechnet
                    if (this.data.winnerMode === 1) {
                        if (i === 0) {
                            eloDeltas[activeIds[i]] += K_FACTOR * (1 - expA); // Gewinner A bekommt Punkte von B
                            eloDeltas[activeIds[j]] += K_FACTOR * (0 - expB); // Verlierer B verliert Punkte an A
                        }
                        continue;
                    }

                    // Normalfall: Jeder gegen Jeden im Ranking
                    eloDeltas[activeIds[i]] += K_FACTOR * (scoreA - expA);
                    eloDeltas[activeIds[j]] += K_FACTOR * (scoreB - expB);
                }
            }

            // Anwenden
            this.data.players = this.data.players.map(p => {
                if (eloDeltas[p.id] !== undefined) {
                    const isWinner = activeIds[0] === p.id;
                    return {
                        ...p,
                        elo: p.elo + eloDeltas[p.id],
                        matches: p.matches + 1,
                        wins: isWinner ? p.wins + 1 : p.wins
                    };
                }
                return p;
            });

            const newHistoryEntry = {
                date: new Date().toLocaleDateString('de-DE', { hour: '2-digit', minute: '2-digit' }),
                mode: this.data.winnerMode,
                ranking: activeIds
            };

            // Daten speichern
            this.saveData(newHistoryEntry)
                .then(() => {
                    this.data.history.unshift(newHistoryEntry);
                    this.data.matchInputs = Array(8).fill('');
                    this.data.activeTab = 'rank';
                    this.render();
                })
                .catch(() => {
                    alert("Match berechnet, aber Speichern in der Datenbank fehlgeschlagen!");
                });
        },

        exportCSV() {
            // (Funktion wie gehabt)
        },

        // --- RENDERING ---
        render() {
            // (Funktion wie gehabt)
        },
        
        renderError() {
            const container = document.getElementById('app-content');
            if (!container) return;
            container.innerHTML = `
                <div class="p-5 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                    <h2 class="font-bold mb-2">Verbindungsfehler</h2>
                    <p>Die Daten konnten nicht von der Datenbank geladen werden. Bitte prüfen Sie:</p>
                    <ul class="list-disc ml-5 mt-2 text-sm">
                        <li>Sind die **SUPABASE_URL** und der **ANON_KEY** im Code korrekt?</li>
                        <li>Sind die **RLS-Policies** (Sicherheitsregeln) in Supabase für **SELECT/READ** aktiv?</li>
                    </ul>
                </div>
            `;
        },

        renderRank(container) {
            // (Funktion wie gehabt)
        },

        renderMatch(container) {
            // (Funktion wie gehabt)
        },

        renderSettings(container) {
            // (Funktion wie gehabt)
        }
    };

    // Start App
    app.init();
</script>
</body>
</html>
